// This file was auto-generated by Fern from our API Definition.

package petstoreferndefapi

import (
	json "encoding/json"
	fmt "fmt"
	core "sdk/core"
)

type FindPetsByStatusRequest struct {
	// Status values that need to be considered for filter
	Status *PetStatus `json:"-"`
}

type FindPetsByTagsRequest struct {
	// Tags to filter by
	Tags *string `json:"-"`
}

type AddPetRequest struct {
	Name string `json:"name"`
	// A list of publicly available URLs featuring the Pet
	PhotoUrls []string   `json:"photoUrls,omitempty"`
	Category  *Category  `json:"category,omitempty"`
	Tags      []*Tag     `json:"tags,omitempty"`
	Status    *PetStatus `json:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AddPetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AddPetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddPetRequest(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddPetRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Pet struct {
	// A unique ID for the Pet
	Id int `json:"id"`
	// The first name of the Pet
	Name string `json:"name"`
	// A list of publicly available URLs featuring the Pet
	PhotoUrls []string  `json:"photoUrls,omitempty"`
	Category  *Category `json:"category,omitempty"`
	Tags      []*Tag    `json:"tags,omitempty"`
	// Pet status in the store
	Status *PetStatus `json:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Pet) UnmarshalJSON(data []byte) error {
	type unmarshaler Pet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Pet(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Pet) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PetStatus string

const (
	PetStatusAvailable PetStatus = "available"
	PetStatusPending   PetStatus = "pending"
	PetStatusSold      PetStatus = "sold"
)

func NewPetStatusFromString(s string) (PetStatus, error) {
	switch s {
	case "available":
		return PetStatusAvailable, nil
	case "pending":
		return PetStatusPending, nil
	case "sold":
		return PetStatusSold, nil
	}
	var t PetStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PetStatus) Ptr() *PetStatus {
	return &p
}

type UpdatePetRequest struct {
	Id   int     `json:"id"`
	Name *string `json:"name,omitempty"`
	// A list of publicly available URLs featuring the Pet
	PhotoUrls []string   `json:"photoUrls,omitempty"`
	Category  *Category  `json:"category,omitempty"`
	Tags      []*Tag     `json:"tags,omitempty"`
	Status    *PetStatus `json:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpdatePetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdatePetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdatePetRequest(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePetRequest) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdatePetWithFormRequest struct {
	// Name of Pet that needs to be updated
	Name *string `json:"-"`
	// Status of Pet that needs to be updated
	Status *string `json:"-"`
}
